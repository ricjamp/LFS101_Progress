# Learning Objectives

By the end of this chapter, you should be able to:
- Explain the features and capabilities of bash shell scripting.
- Know the basic syntax of scripting statements.
- Be familiar with various methods and constructs used.
- Test for properties and existence of files and other objects.
- Use conditional statements, such as if-then-else blocks.
- Perform arithmetic operations using scripting language.
# Features and Capabilities
## Shell Scripting
- suppose you want to look up a filename, check if the associated file exists, and then respond accordingly, displaying a message confirming or not confirming the file's existence
	- if you only need to do it once, you can just type a sequence of commands at a terminal
- however, if you need to do this multiple times, automation is the way to go
- in order to automate sets of commands, you will need to learn how to write shell scripts
- most commonly in Linux, these scripts are developed to be run under the bash command shell interpreter
- ==Features of Shell Scripts==:
	- automate tasks and reduce risk of errors
	- combine long and repetitive sequences of commands into one simple command
	- share procedures among several users
	- provide a controlled interface to users
	- create new commands using combination of utilities
	- quick prototyping, no need to compile
## Command Shell Choices
- the command interpreter is tasked with executing statements that follow it in the script
- commonly used interpreters include:
	- /usr/bin/perl, /bin/bash, /bin/csh, /usr/bin/python, /bin/sh
- typing a long sequence of commands at a terminal window can be complicated, time consuming, and error prone
- by deploying shell scripts, using the command line becomes an efficient and quick way to launch complex sequences of steps
- the fact that shell scripts are saved in a file also makes it easy to use them to create new script variations and share standard procedures with several users
- Linux provides a wide choice of shells; exactly what is available on the system is listed in "/etc/shells". Typical choices are:
	- /bin/sh
	- /bin/bash
	- /bin/tcsh
	- /bin/csh
	- /bin/ksh
	- /bin/zsh
- most Linux users use the default bash shell, but those with long UNIX backgrounds with other shells may want to override the default
## Shell Scripts
- a shell is simply a ==command line interpreter== which provides the user interface for terminal windows
- a command shell can also be used to run scripts, even in non-interactive sessions without a terminal window, as if the commands were being directly typed in
	- eg. typing "find . -name "\*.c" -ls" at the command line accomplishes the same thing as executing a script file containing the lines:
		- \#\!/bin/bash
		- find . -name "\*c" -ls
			- the first line of the script, which starts with "#!", contains the full path of the command interpreter (in this case /bin/bash) that is to be used on the file
			- there are quite a few choices for the scripting language you can use, such as:
				- /usr/bin/perl
				- /usr/bin/python
				- /bin/csh
			- the special two-character sequence "#!", is often called a "shebang", and avoids the usual rule that the pound sign '#', delineates the ff. text as a comment
### A Simple bash Script
- let's write a simple bash script that displays a one line message on the screen:
	- $ cat > hello.sh
	- #!/bin/bash
	- echo "Hello, Student"
	- or just create hello.sh in your favorite text editor
	- run the script file by:
		- making it executable through "chmod +x hello.sh", then "./hello.sh"
		- "bash hello.sh"
### Interactive Example using bash Scripts
- now, let's see how to create a more interactive example using a bash script
- the user will be prompted to enter a value, which is then displayed on the screen
	- the value is stored in a temporary variable, name
		- we can reference the value of a shell variable by using a $ in front of the variable name, such as $name
- to create this script, you need to create a file named getname.sh in your favorite editor with the following content:
	- #!/bin/bash  
	- \# Interactive reading of a variable  
	- echo "ENTER YOUR NAME"  
	- read name  
	- \# Display variable input  
	- echo "The name given was :$name"
## Return values
- all shell scripts generate a return value upon finishing execution
	- which can be explicitly set with the "exit" statement
- return values permit a process to monitor the exit state of another process
	- often in a parent-child relationship
- knowing how the process terminates enables taking any appropriate steps which are necessary or contingent on success or failure
### Viewing Return values
- as a script executes
	- one can check for a specific value or condition
		- and return success or failure as the result
- by convention
	- success is returned as zero (0)
	- failure is returned as any non-zero value
- any easy way to demonstrate success and failure completion is to execute the "ls" program on a file that exists, as well as one that does not
- the ==return value is stored in the environment variable represented by $?==:
	- $ ls /etc/logrotate.conf
	- /etc/logrotate.conf
	- $ echo $?
	- 0
	- in this example, the system is able to locate the file "/etc/logrotate.conf" and "ls" returns a value of 0 to indicate success
	- when run on a non-existing file, it returns 2
- applications often translate these return values into meaningful messages easily understood by the user
- usually, the specific values that can be returned and their meanings are explained in the man page for the program
# Syntax
## Basic Syntax and Special Characters
- scripts require you to follow a standard language syntax
- rules delineate how to define variables and how to construct and format allowed statements
- the table lists some special character usages within bash scripts:

| CHAR | DESC                                                                                                                                                                       |
| ---- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \#   | used to add a comment, except when used as \# or as #! when starting a script                                                                                              |
| \\   | used at the end of a line to indicate continuation on to the next line, or to indicate that the next character is to be interpreted literally (escape character), as in \$ |
| \;   | used to interpret what follows as a new command to be executed after completion of the current command                                                                     |
| \$   | indicates what follows is an environment variable                                                                                                                          |
| \>   | redirect output                                                                                                                                                            |
| \>\> | append output                                                                                                                                                              |
| <    | redirect input                                                                                                                                                             |
| \|   | used to pipe the result into the next command                                                                                                                              |
## Splitting Long Commands over Multiple Lines
- sometimes, commands are too long to either easily type on one line, or to grasp and understand
	- even though there is no real practical limit to the length of a command line
- in this case, the concatenation operator '\\', the backslash character, is used to continue long commands over several lines
- here is an example of a command installing a long list of packages on a system using Debian package management:
	- $~/> cd $HOME
	- $~/> sudo apt install autoconf automake bison build-essential \
	-          chrpath curl diffstat emacs flex gcc-multilib g++-multilib
	- the command is divided into multiple lines to make it look readable and easier to understand
	- the '\\' operator at the end of each line causes the shell to continue (concatenate) multiple lines and execute them as one single command
## Putting Multiple Commands on a Single Line
- users sometimes need to combine several commands and statements and even conditionally execute them based on the behavior of operators used in between them
	- this method is called =="chaining of commands"==
- there are several ways to do this, depending on what you want to do:
	- the =='\;' (semicolon) character is used to separate these commands and execute them sequentially==, as if they had been typed on several lines
		- each ensuing command is executed whether or not the preceding one succeeded
		- the three commands in the ff. example will all execute, even if the ones preceding them fail:
			- $ make ; make install ; make clean
	- however, you may want to ==abort subsequent commands when an earlier one fails==
		- you can do this ==using the "&&" (and) operator==, as in:
			- $ make && make install && make clean
		- if the first command fails, the second one will never be executed
	- a final refinement is to ==use the "||" (or) operator==, as in:
		- $ cat file1 || cat file2 || cat file3
		- in this case, you ==proceed until something succeeds and then you stop executing any further steps==
- chaining commands is not the same as piping them 
	- in the latter, succeeding commands begin operating on data streams produced by earlier ones before they complete
	- while in chaining, each step exits before the next one starts
## Output Redirection
- most OSs accept input from the keyboard and display the output on the terminal
- however, with shell commands and scripts, you can send the output to a file
	- the ==process of diverting the output to a file== is called "output redirection"
- the =='>' character== is used to write output to a file
- eg. the ff. command sends the output of "free" to "/tmp/free.out":
	- $ free > /tmp/free.out
	- use "cat" to check the contents of "/tmp/free.out"
- two '>' characters (ie. >>) will append output to a file if it exists, and act just like '>' if the file does not already exist
## Input Redirection
- just as the output can be redirected to a file, the input of a command can be read from a file
- the process of reading input from a file is called "input redirection" and uses the '<' character
- the ff. three commands (using "wc" to count the number of lines, words and characters in a file) are entirely equivalent and involve input redirection, and a command operating on the contents of a file:
	- $ wc < /etc/passwd
	- $ wc /etc/passwd
	- $ cat /etc/passwd | wc
## Built-in Shell Commands
- shell scripts execute sequences of commands and other types of statements
- these commands can be:
	- compiled applications
	- built-in bash commands
	- shell scripts or scripts from other interpreted languages, such as perl and Python
- compiled applications are binary executable files, usually residing on the filesystem in well-known directories such as /usr/bin
- shell scripts always have access to applications in the default path, such as:
	- rm, ls, df, vi, and gzip
		- which are programs compiled from lower-level programming languages such as C
- in addition, bash has many built-in commands, which can only be used to display the output within a terminal shell or shell script
	- sometimes, these commands have the same name as executable programs on the system, which can lead to subtle problems
	- these built-in commands include:
		- cd, pwd, echo, read, logout, printf, let, time, and ulimit
	- thus, slightly different behavior can be expected from the built-in version of a command such as "echo" as compared to /bin/echo
- a complete list of bash built-in commands can be found in the bash man page, or by simply typing "help"
## Script Parameters
- users often need to pass parameter values to a script, such as a filename, date, etc
- scripts will take different paths or arrive at different results according to the parameters (command arguments) that are passed to them
- these values can be text or numbers as in:
	- $ ./script.sh /tmp
	- $ ./script.sh 100 200
- within a script, the parameter or an argument is represented with a '$' and a number or special character
- the table lists some of these parameters

| PARA        | MEAN                         |
| ----------- | ---------------------------- |
| $0          | script name                  |
| $1          | first parameter              |
| $2, $3, etc | second, third parameter, etc |
| $*          | all parameters               |
| $#          | number of arguments          |
### Using Script Parameters
![[Pasted image 20250617203517.png]]
- if you type in the script shown in the figure, make the script executable
- then, run the script giving it several arguments, as shown
- the script is processed as follows:
	- $0 prints the script name: param.sh
	- $1 prints the first parameter: one
	- $2 prints the second parameter: two
	- $3 prints the third parameter: three
	- $* prints all the parameters: one two three four five
	- the final statement becomes: All done with param.sh
## Command Substitution
- at times, you may need to substitute the result of a command as a portion of another command
- it can be done in two ways:
	- by enclosing the inner command in $()
	- by enclosing the inner command with backticks (')
	- ==NOTE==: the second form using backticks is deprecated, and its use should be avoided in new scripts and commands
- no matter which method is used, the specified command will be executed in a newly launched shell environment and the standard output of the shell will be inserted where the command substitution is done
- virtually any command can be executed this way
- while both of these methods enable command substitution
	- the ==$() method allows command nesting==
	- while the use of backticks does not because the right and left delimiters are identical
	- new scripts should always use this more modern method
- eg.
	- $ ls /lib/modules/$(uname -r)/
	- in the above example, the output of the command "uname -r" (which will be something like 6.2.4) is inserted into the argument for the "ls" command
## Environment Variables
- most scripts use variables containing a value, which can be used anywhere in the script
	- these variables can either be user or system-defined
		- many applications use such environment variables for supplying inputs, validation, and controlling behavior
- some examples of standard environment variables are HOME, PATH, and HOST
	- when referenced, environment variables must be prefixed with the '$' symbol, as in $HOME
- you can ==view and set the value of environment variables==
	- eg. the ff. command displays the value stored in the PATH variable:
		- $ echo $PATH
- however, ==no prefix is required when setting or modifying the variable value==
	- eg. the ff. command sets the value of the MYCOLOR variable to blue
		- $ MYCOLOR=blue
- you can get a list of environment variables with the "env", "set", or "printenv" commands
## Exporting Variables
- while we discussed the export of environment variables in the section on the "User Environment", it is worth reviewing in the context of writing bash scripts
- by default, the ==variables created within a script are available only to the subsequent steps of that script==
	- ==any child processes (sub-shells) do not have automatic access to the values of these variables==
- to ==make them available to child processes==, they must be ==promoted to environment variables using the export statement==, as in:
	- $ export VAR=value
	- or, VAR=value ; export VAR
- while ==child processes are allowed to modify the value of exported variables==, the ==parent will not see any changes==
	- ==exported variables are not shared, they are only copied and inherited==
- typing "export" with no arguments will give a list of all currently exported environment variables
## Functions
- a function is a ==code block that implements a set of operations==
- functions are useful for executing procedures multiple times, perhaps with varying input variables
- functions are also often called ==subroutines==
- using functions in scripts requires two steps:
	- declaring a function
	- calling a function
- the function declaration requires a name which is used to invoke it
	- the proper syntax is:
		- function_name () {
		     command...
		 }
	- eg. the ff. function is named display:
		- display () {
			 echo "This is a sample function that just displays a string"
		 }
- the function can be as long as desired and have many statements
- once defined, the function can be called later as many times as necessary
# Constructs
## if Statement
- conditional decision making, using an "if" statement , is a basic construct that any useful programming or scripting language must have
- when an "if" statement is used, the ensuing actions depend on the evaluation of specified conditions, such as:
	- numerical or string comparisons
	- return value of a command (0 for success)
	- file existence or permissions
- in compact form, the syntax of an "if" statement is:
	- if TEST-COMMMANDS; then CONSEQUENT-COMMANDS; fi
- a more general definition is:
	- if condition
	- then
		- statements
	- else
		- statements
	- fi
### using the if statement
- in the ff. example, an "if" statement checks to see if a certain file exists, and if the file is found, it displays a message indicating success or failure:
	- if \[ -f "$1"\ ]
	- then
		- echo "file $1 exists"
	- else
		- echo "file $1 does not exist"
	- fi
- we really should also check first that there is an argument passed to the script ($1) and abort if not
- notice the use of the square brackets ( \[ \] ) to delineate the test condition
- there are many other kinds of tests you can perform, such as checking whether two numbers are equal to, greater than, or less than each other and make a decision accordingly
- in modern scripts, you may see doubled brackets as in ( \[\[ -f /etc/passwd \]\] )
	- this is not an error
	- it is never wrong to do so and it avoids some subtle problems, such as referring to an empty environment variable without surrounding it in double quotes
### elif Statement
- you can use the "elif" statement to perform more complicated tests, and take appropriate actions
- the basic syntax is:
	- if \[ sometest \]; then
		- statement
	- elif \[ someothertest \]; then
		- statement
	- fi
## Testing for Files
- bash provides a set of file conditionals that can be used with the "if" statement, including those in the table
- you can use the "if" statement to test for file attributes, such as:
	- file or directory existence
	- read or write permission
	- executable permission
- eg.
	- if \[ -x /etc/passwd \]; then
		- ACTION
	- fi
	- this checks if the file "/etc/passwd" is executable, which it is not
	- ==NOTE== the very common practice of putting "; then" on the same line as the "if" statement
- you can view the full list of file conditions (and other test conditions) in:
	- ==man 1 test==
## Boolean Expressions
- Boolean expressions evaluate to either TRUE or FALSE, and results are obtained using the various Boolean operators listed in the table
- "&&" Operator
	- AND: the action will be performed only if both the conditions evaluate to true
- "||" Operator
	- OR: the action will be performed if any one of the conditions evaluate to true
- '!' Operator
	- NOT: the action will be performed only if the condition evaluates to false
- note that if you have multiple conditions strung together with the "&&" operator, processing stops as soon as a condition evaluates to false
	- eg. A && B && C
		- A is true but B is false, C will never be executed
- likewise, if you are using the "||" operator, processing stops as soon as anything is true
	- eg. A || B || C
		- A is false and B is true, you will also never execute C
### Tests in Boolean Expressions
- Boolean expressions return either TRUE or FALSE
- we can use such expressions when working with multiple data types, including strings or numbers, as well as with files
- eg. to check if a file exists, use the ff. conditional test:
	- \[ -e \<filename\> \]
- similarly, to check if the value of number1 is greater than the value of number2, use the ff. conditional test:
	- \[ $number1 -gt $number2 \]
	- the operator "-gt" returns TRUE if number1 is greater than number2
### Example of Testing in Strings
- you can use the "if" statement to compare strings using the "\=\=" operator (two equal signs)
- the syntax is as follows:
	- if \[ string1 \=\= string2 \]; then
		- ACTION
	- fi
	- ==NOTE==: using one equal sign (\=) will also work, but some consider it deprecated usage
## Numerical Tests
- you can use specially defined operators with the "if" statement to compare numbers
- the various operators that are available are listed below:
	- "-eq": equal to
	- "-ne": not equal to
	- "-gt": greater than
	- "-lt": less than
	- "-ge": greater than or equal to
	- "-le": less than or equal to
- the syntax for comparing numbers is as follows:
	- exp1 -op exp2
### Example of Testing for Numbers
![[Pasted image 20250618233513.png]]
## Arithmetic Expressions
- arithmetic expressions can be evaluated in the ff. three ways (==spaces are important==):
	- "expr" utility:
		- "expr" is a standard but somewhat deprecated program
		- expr 8 + 8
		- echo $(expr 8 + 8)
		- 16
	- $((...)) syntax:
		- this is the built-in shell format
		- echo $((8+1))
		- 9
	- "let" command:
		- let x=( 1 + 2 ); echo $x
		- 3
- in modern shell scripts, the use of "expr" is better replaced with var=$((...))
# Labs 16.1 - Simple Calculator
Write a script that will act as a simple calculator for add, subtract, multiply and divide.
1. Each operation should have its own function.
2. Any of the three methods for bash arithmetic, (**$((..))**, **let**, or **expr**) may be used.
3. The user should give 3 arguments when executing the script:  
    - The first should be one of the letters **a**, **s**, **m**, or **d** to specify which math operation.  
    - The second and third arguments should be the numbers that are being operated on.
4. Â The script should detect for bad or missing input values and display the results when done.
## My Solution
$ vim simplecalc.sh
\#!/bin/bash
\# check for bad or missing input values
number_check='^\[0-9\]+$'
letter_check='^\[asmd\]$
if \[\[ $# -ne 3 \]\]; then
	echo "Please enter only 3 arguments"
	exit
elif \[\[ ! $1 =~ $letter_check \]\]; then
	echo "First argument should be a, s, m or d"	
	exit
elif \[\[ ! $2 =~ $number_check \]\] || \[\[ ! $3 =~ $number_check \]\]; then
	echo "Second and Third arguments must be an integer"
	exit
fi
\# do calculations
add_them () {
	echo "$(( $1 + $2 ))"
}
sub_them () {
	echo "$(( $1 - $2 ))"
}
mul_them () {
	echo "$(( $1 *+* $2 ))"
}
div_them () {
	echo "$(( $1 / $2 ))"
}
if \[\[ $1 == "a" \]\]; then
	add_them $2 $3
elif \[\[ $1 == "s" \]\]; then
	sub_them $2 $3
elif \[\[ $1 == "m" \]\]; then
	mul_them $2 $3
elif \[\[ $1 == "d" \]\]; then
	div_them $2 $3
fi

==NOTE==: 
- functions cannot access environment variables, do either of the ff. to make it work:
	- pass the value of the environment variables to the function
	- declare a new variable with the value of the environment variable
	- export the environment variables (ie. export myvar=$2)