# Learning Objectives

By the end of this chapter, you should be able to:
- Use the command line to perform operations in Linux.
- Search for files.
- Create and manage files.
- Install and update software.

# Command Line
"Graphical User Interfaces make easy tasks easier, while command line interfaces make difficult tasks possible"
## Command Line Interface (CLI) Benefits:
- no GUI overhead
- virtually any and every task can be accomplished while sitting at the command line
- you can implement scripts for often-used (or easy-to-forget) tasks and series of procedures
- you can sign into remote machines anywhere on the internet
- you can initiate graphical applications directly from the command line
- while graphical tools may vary among Linux distros, the command line interface does not
## Input Lines
- most input lines entered at the shell prompt have three basic elements:
	- Command
		- name of the program or script you are executing
	- Options
		- usually starts with one or two dashes
			- eg: "-p" or "--pprint"
		- modifies what the command may do
	- Arguments
		- sometimes called a "positional parameter"
		- these represent what the command operates on
		- eg: man head, here "head" is the argument since our command is "man"
## sudo
- allows the user running the program or command to use the security privileges of root (superuser)
## Basic Operations / Utilities
- ### Shutdown and Reboot
	- ==reboot==: (requires sudo) also, shutdown -r
	- ==shutdown==: (requires sudo) shuts down the system, accepts time and message parameters
- ### Accessing Directories
	- default directory is $Home or $Home/Desktop
	- ==Absolute pathname==
		- begins with the root directory (/) and follows the tree (directory), until you reach the desired directory or file
	- ==Relative pathname==
		- starts from the present working directory. Never starts with '/'
		- you can use relative paths to work with files and directories by using ".." to access the parent directory
	- ==pwd==: displays the Present Working Directory
	- ==ls==: list the contents of the present working directory
		- -a option: include hidden files and directories
	- ==tree==: displays a tree view of the filesystem
	- ==cd== ~ or cd: Change Directory, '~' tilde symbol is a shortcut for $Home directory
	- ==cd ..== : cd with 2 periods : Change to Parent Directory (Go one level up)
	- ==cd -== : cd with a dash or minus : Change to Previous Working Directory
	- ==pushd==: creates a directory stack (Last In, First Out), allowing users to easily switch between directories
		- -n option: pushes a directory below the top of the stack
		- +N (from top) or -N (from bottom) option: moves to that position in the stack, position of the stack is kept for non-top stack items
	- ==popd==: removes the top directory from the stack
	- ==dirs -l -v==: displays the directory stack, with option -l as list and option -v for values
	- ==popd==: removes the top of the directory stack
- ### Hard Links and Soft Links
	- ==ln==: creates a hardlink between 2 files, essentially creating another name for file1 for you to access its contents
		- eg: ln file1 file2 - file2 is now another name for file1 - same content - same inode
		- this saves space in the filesystem, when you want a file to be in multiple directories
		- ls -li option: shows the inode numbers to see if files have a hard link (similar inode number)
	- Hard links are limited to the same filesystem, and are limited to files
	- ==ln -s==: creates a soft (symbolic) link between 2 objects / files / directories, file2 becomes a shortcut to file1
		- best used as a "shortcut" for quickly accessing very long directory names
		- instead of /usr/bin/this/that/mydir, creating a soft link will work faster
	- Unlike hard links, symbolic links can span multiple filesystems and be used on directories
- ### Working with Files
	- ==cat==: used to type out a file (or combine files)
	- ==tac==: used to look at a file backwards, starting with the last line
	- ==less==: used to view larger files because it is a paging program.
		- pauses at each screen full of text, provides scroll-back capabilities, and let's you search and navigate within the file
	- ==tail==: used to show the last 10 lines of a file
		- 10 is the default, change with "-n \<number\>" option
	- ==head==: used to show the first few lines of a file
		- 10 is the default, change with "-n \<number\>" option
	- ==touch==: used to set or update the access, change, and modify times of files.
		- by default, resets a file's timestamp to match the current time
		- can also be used to create an empty file
		- "-t \<MMDDhhmm\>" option to specify the date
	- ==mkdir \<path/dirname\>==: creates a directory
	- ==rmdir \<path/dirname\>==: removes an empty directory
	- ==mv==: moves a file and optionally, rename it
	- ==rm==: remove a file or directory
		- "-f" option: forcefully remove a file
		- "-i" option: "interactively" remove a file (prompts you before removing it)
		- "-r" option: recursively remove a directory (including all contents)
- ### Command Modifiers
	- ==man \<command\>==: used to view documentation for a command
	- ==PS1 variable==: the character string that is displayed as the prompt on the CLI
		- eg. student@r9:\<directory\>$
		- can be modified
- ### Locating Applications
	- ==which==: returns the path of the program in the filesystem
	- ==whereis==: broader search range than which, returns path of arguments
- ### I/O Redirection
	- we can redirect the three standard file streams so that we can get input from either a file or another command, instead of from our keyboard, and we can write output and errors to files or use them to provide input for subsequent commands
	- eg: 
		- do_something ==<== input-file
			- the output of input-file, will be used by do_something command
		- do_something ==\>== output-file
			- the output of do_something command, will be saved to output-file
		- do_something ==< input-file >== output-file
			- the output of do_something command, will be saved to output-file
	- because stderr is not the same as stdout, error messages will still be seen on the terminal windows in the above example (this only creates an empty file, not write the error to it)
	- if you want to redirect stderr to a separate file, you use stderr's file descriptor number (2), the greater-than-sign (>), followed by the name of the file you want to receive everything the running command writes to stderr:
		- do_something ==2>== error-file
	- a special shorthand notation can send anything written to file descriptor 2 (stderr) to the same place as file descriptor 1 (stdout)
		- ==2>&1==, this means stderr output goes to stdout output
		- a shorthand for this would be: ==\>&==
	- - ==' | '==: pipe symbol; used to have one program take as input the output of another
		- eg: man head | head, "head" will take as input the output of "man head"
		- eg: man head | head | tail -n 1
- ### Searching for Files
	- ==locate==: performs a search using the database created from the ==updatedb utility==, matching all entries that contain a specified character string
		- eg: locate zip | grep bin (see grep below)
	- ==grep==: acts as filter, printing (on the terminal) only the lines that contain one or more specified strings (reg ex)
	- ==Wildcard symbols==:
		- Examples: Assume Directory has these files: cat.txt, car.txt, cab.txt
		- =='?'==: matches any character
			- eg: ca?.txt - finds all three files
		- =='\*'==: matches any string of characters
			- eg: \*.txt - finds all .txt files
			- eg: \*t.txt - finds cat.txt only
		- =='\[set\]'==: matches any character in the set of characters, for example \[adf\] will match any occurrence of a, d, or f 
		- =='\[!set\]'==: matches any character not in the set of characters
- ### Find command
	- ==find==: recurses down the filesystem tree from any particular directory and locates files that match specific conditions
		- default pathname is always the present working directory
		- "name": only list files with a certain pattern in their name
		- "iname": list files with a pattern and ignore the Case
		- "-type" option: restricts results to 'd' directories, 'f' files, 'l' symbolic links, etc
		- "-maxdepth" option: how many levels will it find
		- eg: "find /usr -name gcc" search for files and directories named gcc
		- eg: "find /usr -type d -name gcc" search for directories named gcc
	- ==Advanced Find Options==:
		- another good use of find is being able to run commands on the files that match your search criteria using the =="-exec" option==
		- eg: To find and remove all files that end with .swp:
			- $ find -name "\*.swp" -exec rm {} ';'
			- "{}" is a placeholder that will be filled with all the file names that result from the find expression, and the preceding command will be run on each one individually
			- End the command with either ';' (including quotes) or \\;
			- an alternative to "-exec" is =="-ok"==, but prompts you for permission before executing the command
	- ==Finding Files based on Time and Size==:
		- sometimes, you want to find files according to their attributes, like last used, created, size, etc.
		- \<n\>: 
			- refers to a number depending on what option is used
			- this could be n days or minutes
			- or sizes with C / K / M / G options for bytes / kilobytes / megabytes / gigabytes
			- also works with '+' or '-', greater than and less than, respectively
		- -ctime \<n\>: find based on inode metadata (usually when file was first created)
		- -atime \<n\>: find based on last access
		- -mtime \<n\>: find based on last modified
		- -size \<n\>: find based on size
			- eg: find / -size +10M -exec command {} ';'
			- find files greater than 10 MB in size, and run a command on them
## Standard File Streams
- When commands are executed, by default there are three standard file streams (or descriptors) always open for use:
	- Standard input
		- Symbolic name: stdin
		- Value: 0
		- Eg: keyboard
	- Standard output
		- Symbolic name: stdout
		- Value: 1
		- Eg: terminal
	- Standard error
		- Symbolic name: stderr
		- Value: 2
		- Eg: log file
## Package Management Systems
- installs the core parts of a Linux distro and add-on software
- packages can depend on each other
	- eg: A Package written in Python, will sometimes require the Python package to run
- Two Broad Families:
	- Debian
	- RPM
- Two Levels:
	- ==Low-level tool==:
		- takes care of the details of unpacking individual packages, running scripts, getting the software installed correctly
		- eg: dpkg or rpm
	- ==High-level tool==:
		- works with groups of packages, downloads packages from the vendor, and figures out dependencies
		- eg: apt, dnf or zypper
- ==apt==:
	- provides the backend for graphical package managers like Ubuntu Software Center
- ==dnf==:
	- open source command-line package-management utility (RPM based) for Red Hat Family
- ==zypper==:
	- package management system for SUSE family (RPM based)
	- also allows you to manage repositories from the command line
	- fairly straightforward to use and closely resembles dnf
![[Pasted image 20250529215434.png]]

